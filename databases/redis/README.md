# Redis

# 数据结构
- String
	- **应用场景:** String 是最常用的数据类型, 普通的 Key/Value 都可以归为此类。
	- **数据容量:** 一个 String 类型的 Value 最大可以存储 512M。
- Hash
	- **应用场景:** 存储对象。比如一个用户的信息。
	- **数据容量:** Hash 的元素个数最多为 2^32-1 个，也就是 4294967295 个。
	- **实现方式:** Redis 的 Hash 对应的 Value 内部实际就是一个 HashMap, 实际有两种不同的实现,
					如果成员较少时, Redis为了节省内存会采用类似一维数组方式存储, 当成员数量增大时会自动转成真正的HashMap。
- List
	- **应用场景:** 消息队列。利用 Lists 的 push 的操作, 将任务存储在 List 中, 然后工作线程再用 Pop 操作将任务取出进行执行。
	- **数据容量:** List 的元素个数最多为 2^32-1 个，也就是 4294967295 个。
	- **实现方式:** Redis List 的实现是一个双向链表, 可以支持反向查找和遍历, 更方便操作, 不过带来了部分额外的内存开销,
					Redis 内部的很多实现, 包括发送缓冲队列等也都用的是这个数据结构。
- Set
	- **应用场景:** Set 类似 List, 特殊之处是 Set 可以自动排重。Set 还提供了某个成员是否在一个 Set 内的接口, 这个也是 List 没有的。
	- **数据容量:** Set 的元素个数最多为 2^32-1 个，也就是 4294967295 个。
	- **实现方式:** Set 内部实现是一个 value 永远为 null 的 HashMap, 实际就是通过 Hash 的方式快速排重的。
- Sort Set
	- **应用场景:** Sort Set 的使用场景与 Set 类似, 区别是 Set 不是自动有序的,
					而 Sort Set 可以通过用户额外提供一个优先级 (score) 的参数来为成员排序, 并且是插入有序的, 即自动排序。
	- **数据容量:** Sort Set 的元素个数最多为 2^32-1 个，也就是 4294967295 个。
	- **实现方式:** Redis Sort Set 的内部使用 HashMap 和跳跃表 (SkipList) 来保证数据的存储和有序, HashMap 里放的是成员到 score 的映射,
					而跳跃表里存放的是所有的成员, 排序依据是 HashMap 里存的 score, 使用跳跃表的结构可以获得比较高的查找效率, 并且在实现上比较简单。

# 过期策略
- **定期删除:** 所谓定期删除, 指的是 redis 默认是每隔 100ms 就随机抽取部分设置了过期时间的 key, 检查其是否过期, 如果过期就删除。
- **惰性删除:** 指的是, 在你获取某个 key 的时候, redis 会检查一下, 这个 key 如果设置了过期时间那么是否过期了？ 如果过期了此时就会删除, 不会给你返回任何东西。

# 内存淘汰
- **noeviction:**       当内存不足以容纳新写入数据时，新写入操作会报错。
- **allkeys-random:**   当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- **allkeys-lru:**      当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。(常用)
- **volatile-random:**  当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- **volatile-lru:**     当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- **volatile-ttl:**     当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

# 数据持久化
- **RDB:**
